package com.intbyte.bw.jsondb

import com.badlogic.gdx.utils.Array
import com.badlogic.gdx.utils.JsonValue

class JavaBuilder : AbstractBuilder {

    private val map = mutableMapOf<String, Array<JsonValue>>()
    private val head = """
        package com.intbyte.bw.gen_json_data;
        
        import com.badlogic.gdx.graphics.g2d.Sprite;
        import com.badlogic.gdx.math.Rectangle;
        import com.intbyte.bw.core.game.Player;
        import com.intbyte.bw.game.gameUI.InventoryLayerUI;
        import com.intbyte.bw.game.gameUI.MainLayerUI;
        import com.intbyte.bw.gameAPI.callbacks.CallBack;
        import com.intbyte.bw.gameAPI.callbacks.Initialization;
        import com.intbyte.bw.gameAPI.environment.*;
        import com.intbyte.bw.gameAPI.ui.GUI;
        import com.intbyte.bw.gameAPI.ui.Panel;
        import com.intbyte.bw.gameAPI.physic.PhysicBlockObject;
        import com.intbyte.bw.gameAPI.utils.ID;
        import com.intbyte.bw.gameAPI.utils.Resource;
        import com.intbyte.bw.gameAPI.environment.json_wrapper.BlockWrapper;
        
        //TODO: do not delete, this file was automatically generated by json data generator from json files
        public class GeneratedJsonData{
            public static void init(){
                BlockWrapper blockWrapper = new BlockWrapper();
                Block.CustomBlock block = null;
    """.trimIndent()

    private val end = """

            }
        }
    """.trimIndent()

    override fun build(out: String, jsonValues: Array<JsonValue>) {
        sort(jsonValues)
        map.keys.forEach {
            when (it) {
                "block" -> println(it)
            }
        }

        println("$head${generateBlockData()}$end")
    }

    private fun sort(array: Array<JsonValue>) {
        array.forEach {
            val str = it.get("type")?.asString()?.split(":")?.get(0)
            if (map[str] == null && str != null) map[str] = Array()
            map[str]?.add(it)
        }
    }

    private fun generateBlockData(): String {
        var code = ""

        (map["block"] ?: return "")?.forEach {
            code += """
                
        blockWrapper.reset();
        blockWrapper.setId("${it["type"].asString().split(":")[1]}");
        
        """.trimEnd()

            code+="\n\t\tblockWrapper.setModel(\"${it["model"]?.asString()}\");"
            code+="\n\t\tblockWrapper.setTexture(\"${it["texture"]?.asString()}\");"
            val iconScale = it["iconScale"]?.asString()
            if(iconScale!=null) code+="\n\t\tblockWrapper.setIconScale(${iconScale}f);"

            val iconRenderCoord = it["iconRenderCoord"]?.asStringArray()
            if(iconRenderCoord!=null) code+="\n\t\tblockWrapper.getIconRender().set(${iconRenderCoord[0]}f,${iconRenderCoord[1]}f,${iconRenderCoord[2]}f);"
            code+="\n\t\tblockWrapper.setType(Block.${(it["blockType"]?.asString()?:"STONE").toUpperCase()});"
            code+=

            code+="\n\t\tblock = Block.defineBlock(blockWrapper);\n\t\tblock.updateIcon();".trimEnd()


            val scale = it["scale"]?.asString()
            if(scale!=null) code+="\n\t\tblockWrapper.setScale(${scale}f);"
            val renderCoord = it["renderCoord"]?.asStringArray()
            if(renderCoord!=null) code+="\n\t\tblockWrapper.getRender().set(${renderCoord[0]}f,${renderCoord[1]}f,${renderCoord[2]}f);"

        }
        return code
    }
}


